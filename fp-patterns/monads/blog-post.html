Like many developers, I initially struggled to understand precisely what <em>type</em> of thing monads are, despite using them in my code on an almost daily basis. Learning monads has become something of a rite of passage for functional developers, and the most helpful description I have come across is given by Noel Welsh and Dave Gurnell inÂ <a href="https://underscore.io/books/scala-with-cats/" target="_blank" rel="noopener">Scala with Cats</a>: "A monad is a mechanism for <em>sequencing computations</em>". Monads provide a pattern for abstracting over the effects of these computations, allowing them to be composed into larger programs. In this post, we will discuss three such patterns: the Writer, Reader, and State monads.
<!--more-->
<h3>The Writer Monad</h3>
This pattern provides a means to return a log along with the result of a computation. This is especially useful in multithreaded contexts to avoid the log messages of concurrent computations becoming interleaved. An implementation of the Writer monad is provided in <code>cats.data.Writer</code>, which we can use as follows:

import cats.data.Writer
import cats.instances.vector._

val x = Writer(Vector("some intemediary computation"), 3)
val y = Writer(Vector("another intemediary computation"), 4)

val z = for {
    a <- x
    b <- y
  } yield a + b

// WriterT(Vector(some intemediary computation, another intemediary computation),7)

We can access the result and the log separately:

println(z.value)
// 7
println(z.written)
// Vector(some intemediary computation, another intemediary computation)


